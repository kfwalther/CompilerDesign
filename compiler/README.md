README.txt

This Compiler project/program utilizes ANTLR 4 C++ tools to compile a C- (C-Minus) 
program file. C-Minus is a subset of the C language.

Using CMake to generate the build environment for the project, we place all of the compiler
specific build environment files into the folder 'compiler/VS15W64'. It is named this way because Visual
Studio 15 (2017) was used to build the code. After running CMake, the generated Visual Studio solution
can be opened and the project can be compiled. 

Some ANTLR-generated C++ files are created based on the grammar inputs. These grammar inputs
are specified with the following two files, and the generated C++ code is placed into the
'compiler/compiler/generated' directory.

 - compiler/grammar/TLexer.g4
 - compiler/grammar/TParser.g4
 
One of the targets generated by CMake actually calls an ANTLR .jar file, which is used to 
auto-generate the C++ code from the 'g4' grammar definition files. The generated C++ code
implements much of the scanning and parsing capabilities of the parser.

The custom code written from scratch for this project makes use of the generated files, for
printing Token information and generating a Parse Tree after parsing the input. This custom
code is located in the 'compiler/compiler' directory, and the relevant class files are:

 - AstNode
 - AstVisitor
 - AstVisitorImpl
 - Compiler
 - ErrorHandler
 - LLVMHandler
 - ParseTreeListenerImpl
 - ParseTreeVisitorImpl
 - Scope
 - SemanticAnalyzer
 - SymbolTable
 - SymbolTableManager
 
All of the source code in the 'compiler/compiler' directory is heavily commented to document the 
design decisions and thought-processes that took place during implementation.

Once the project is compiled, the executable will be placed in the 'compiler/VS15W64/compiler/Debug' 
folder. A Windows batch script is provided in the top-level directory to call the executable and run 
the program with all test input files. The test input files themselves are located in the 
compiler/tests directory. This code was built and tested on Windows 7 and Windows 10.
The format for running the compiler program is the executable, followed by an input file name:

ANTLR4GrammarTest.exe C:\Users\user\CompilerDesign\compiler\tests\C-Input-1.txt

After running the program with each input file, the output is piped to a corresponding output
file located in the 'compiler/tests/output' directory. The output prints the following information:

 - Token list
 - Parenthesized parse tree (undecorated)
 - Indented AST (decorated)
 - Symbol Table (with token information and scope numbering)
 - Generated LLVM IR (with some optimization)
 
Tokens have the following format when printed: [@<A>,B:C='D',<E>,F:G]
where A through G translate to:
A: Token Index
B: Symbol Start Position in Entire File
C: Symbol Stop Position in Entire File
D: Token String
E: Token Type Enumeration
F: Token Line Location in File
G: Token Character Position in Line

In addition, symbol table entries and AST nodes have further information populated, some of 
which includes:
 - CMinus Native Type: UNKNOWN, INT, VOID
 - Symbol Record Kind: UNKNOWN, VARIABLE, ARRAY, FUNCTION, NUMBER
 - Rule Type
 - L-value/R-value flags
 - Location stored in memory
 - Storage size in memory
 - Evaluated value

From the generated LLVM, any number of target languages and/or assembly can be created. The 
C++ LLVM API comes with support to convert LLVM assembly into C++ for several target
architectures. To name a few: 
 - AMDGPU
 - ARM
 - Hexagon
 - MIPS
 - PowerPC
 - PISCV
 - Sparc
 - x86
 - xCore
Using the 'llc' tool built with the C++ LLVM API library, an LLVM assembly file 
can be provided as input, the llc tool auto-detects the current architecture from the 
environment, and generates corresponding assembly code. On my machine, this generated Intel
64-bit assembly, seen in the compiler/tests/output/gcd.s file. From there, we can use Microsoft
Visual Studio or MinGW to compile the Intel assembly into an executable that can be run:

gcc inputOutput.c gcd.s -o gcd.exe

Note, we have to provide the function definition/implementation of the C-Minus input() and 
output() built-in functions, as no definition is provided in C-Minus itself. Nonetheless, 
a compiler/tests/output/gcd.exe file is generated by gcc, and we can run the gcd program. This 
program takes two input integers, and computes the GCD of the two inputs, outputting the result
to the screen.

The provided script, compiler/runAndBuildGCD.bat, will run the C-Minus compiler to produce LLVM
assembly, run the llc utility to convert the LLVM to Intel Assembly, and call gcc to compile the 
assembly into an executable.




